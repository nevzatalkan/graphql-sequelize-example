"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('graphql');

var GraphQLObjectType = _require.GraphQLObjectType;
var GraphQLSchema = _require.GraphQLSchema;
var GraphQLInt = _require.GraphQLInt;
var GraphQLString = _require.GraphQLString;
var GraphQLList = _require.GraphQLList;
var GraphQLNonNull = _require.GraphQLNonNull;
var GraphQLBoolean = _require.GraphQLBoolean;
var GraphQLInputObjectType = _require.GraphQLInputObjectType;
var GraphQLID = _require.GraphQLID;

var _ = require('lodash');
var pluralize = require('pluralize');
var camelcase = require('camelcase');

var _require2 = require("graphql-relay");

var fromGlobalId = _require2.fromGlobalId;
var globalIdField = _require2.globalIdField;
var mutationWithClientMutationId = _require2.mutationWithClientMutationId;

var _require3 = require("graphql-sequelize");

var defaultArgs = _require3.defaultArgs;
var defaultListArgs = _require3.defaultListArgs;
var attributeFields = _require3.attributeFields;
var resolver = _require3.resolver;
var _require3$relay = _require3.relay;
var sequelizeNodeInterface = _require3$relay.sequelizeNodeInterface;
var sequelizeConnection = _require3$relay.sequelizeConnection;


var jsonType = require("graphql-sequelize/lib/types/jsonType.js");

function connectionNameForAssociation(Model, associationName) {
  return camelcase(Model.name + '_' + associationName);
}
function queryName(Model, type) {
  switch (type) {
    case 'findAll':
      {
        return camelcase(pluralize.plural(Model.name));
      }
    case 'findById':
      {
        return camelcase(Model.name);
      }
    default:
      {
        console.warn('Unknown query type: ', type);
        return camelcase(type + '_' + Model.name);
      }
  }
}
function mutationName(Model, type) {
  switch (type) {
    case 'create':
      {
        return camelcase(type + '_' + Model.name);
      }
    case 'update':
      {
        return camelcase(type + '_' + pluralize.plural(Model.name));
      }
    case 'updateOne':
      {
        return camelcase('update_' + Model.name);
      }
    case 'delete':
      {
        return camelcase(type + '_' + pluralize.plural(Model.name));
      }
    case 'deleteOne':
      {
        return camelcase('delete_' + Model.name);
      }
    default:
      {
        console.warn('Unknown mutation type: ', type);
        return camelcase(type + '_' + Model.name);
      }
  }
}

function convertFieldsToGlobalId(Model, fields) {
  // Fix Relay Global ID
  _.each(Object.keys(Model.rawAttributes), function (k) {
    if (k === "clientMutationId") {
      return;
    }
    // Check if reference attribute
    var attr = Model.rawAttributes[k];
    if (attr.references) {
      // console.log(`Replacing ${Model.name}'s field ${k} with globalIdField.`);
      var modelName = attr.references.model;
      // let modelType = types[modelName];
      fields[k] = globalIdField(modelName);
    } else if (attr.primaryKey) {
      fields[k] = globalIdField(Model.name);
      // Make primaryKey optional (allowNull=True)
      fields[k].type = GraphQLID;
    }
  });
}

function convertFieldsFromGlobalId(Model, data) {
  // Fix Relay Global ID
  _.each(Object.keys(data), function (k) {
    if (k === "clientMutationId") {
      return;
    }
    // Check if reference attribute
    var attr = Model.rawAttributes[k];
    if (attr.references || attr.primaryKey) {
      var _fromGlobalId = fromGlobalId(data[k]);

      var id = _fromGlobalId.id;

      // Check if id is numeric.

      if (!_.isNaN(_.toNumber(id))) {
        data[k] = parseInt(id);
      } else {
        data[k] = id;
      }
    }
  });
}

function _createRecord(_ref) {
  var mutations = _ref.mutations;
  var Model = _ref.Model;
  var modelType = _ref.modelType;
  var ModelTypes = _ref.ModelTypes;
  var associationsToModel = _ref.associationsToModel;
  var associationsFromModel = _ref.associationsFromModel;
  var cache = _ref.cache;


  var createMutationName = mutationName(Model, 'create');
  mutations[createMutationName] = mutationWithClientMutationId({
    name: createMutationName,
    description: 'Create ' + Model.name + ' record.',
    inputFields: function inputFields() {
      var fields = attributeFields(Model, {
        exclude: Model.excludeFields ? Model.excludeFields : [],
        commentToDescription: true,
        // exclude: [Model.primaryKeyAttribute],
        cache: cache
      });

      convertFieldsToGlobalId(Model, fields);

      // FIXME: Handle timestamps
      // console.log('_timestampAttributes', Model._timestampAttributes);
      delete fields.createdAt;
      delete fields.updatedAt;

      return fields;
    },
    outputFields: function outputFields() {
      var output = {};
      // New Record
      output[camelcase('new_' + Model.name)] = {
        type: modelType,
        description: 'The new ' + Model.name + ', if successfully created.',
        resolve: function resolve(args, e, context, info) {
          return resolver(Model, {})({}, _defineProperty({}, Model.primaryKeyAttribute, args[Model.primaryKeyAttribute]), context, info);
        }
      };

      // New Edges
      _.each(associationsToModel[Model.name], function (a) {
        var from = a.from;
        var atype = a.type;
        var field = a.key;
        // console.log("Edge To", Model.name, "From", from, field, atype);

        if (atype !== "BelongsTo") {
          (function () {
            // HasMany Association
            var connection = associationsFromModel[from][Model.name + '_' + field].connection;

            var fromType = ModelTypes[from];
            // let nodeType = conn.nodeType;
            // let association = Model.associations[field];
            // let targetType = association
            // console.log("Connection", Model.name, field, nodeType, conn, association);
            output[camelcase('new_' + fromType.name + '_' + field + '_Edge')] = {
              type: connection.edgeType,
              resolve: function resolve(payload) {
                return connection.resolveEdge(payload);
              }
            };
          })();
        }
      });
      _.each(associationsFromModel[Model.name], function (a) {
        var to = a.to;
        var atype = a.type;
        var foreignKey = a.foreignKey;
        var field = a.key;
        // console.log("Edge From", Model.name, "To", to, field, as, atype, foreignKey);

        if (atype === "BelongsTo") {
          (function () {
            // BelongsTo association
            var toType = ModelTypes[to];
            output[field] = {
              type: toType,
              resolve: function resolve(args, e, context, info) {
                return resolver(Models[toType.name], {})({}, { id: args[foreignKey] }, context, info);
              }
            };
          })();
        }
      });
      // console.log(`${Model.name} mutation output`, output);
      return output;
    },
    mutateAndGetPayload: function mutateAndGetPayload(data) {
      convertFieldsFromGlobalId(Model, data);
      return Model.create(data);
    }
  });
}

function _findRecord(_ref2) {
  var queries = _ref2.queries;
  var Model = _ref2.Model;
  var modelType = _ref2.modelType;

  var findByIdQueryName = queryName(Model, 'findById'); //`find${Model.name}ById`;
  queries[findByIdQueryName] = {
    type: modelType,
    args: defaultArgs(Model),
    resolve: resolver(Model, {})
  };
}

function _findAll(_ref3) {
  var queries = _ref3.queries;
  var Model = _ref3.Model;
  var modelType = _ref3.modelType;

  var findAllQueryName = queryName(Model, 'findAll');
  queries[findAllQueryName] = {
    type: new GraphQLList(modelType),
    args: defaultListArgs(Model),
    resolve: resolver(Model)
  };
}

function _updateRecords(_ref4) {
  var mutations = _ref4.mutations;
  var Model = _ref4.Model;
  var modelType = _ref4.modelType;
  var ModelTypes = _ref4.ModelTypes;
  var associationsToModel = _ref4.associationsToModel;
  var associationsFromModel = _ref4.associationsFromModel;
  var cache = _ref4.cache;


  var updateMutationName = mutationName(Model, 'update');
  mutations[updateMutationName] = mutationWithClientMutationId({
    name: updateMutationName,
    description: 'Update multiple ' + Model.name + ' records.',
    inputFields: function inputFields() {
      var fields = attributeFields(Model, {
        exclude: Model.excludeFields ? Model.excludeFields : [],
        commentToDescription: true,
        allowNull: true,
        cache: cache
      });

      convertFieldsToGlobalId(Model, fields);

      var updateModelTypeName = 'Update' + Model.name + 'ValuesInput';
      var UpdateModelValuesType = cache[updateModelTypeName] || new GraphQLInputObjectType({
        name: updateModelTypeName,
        description: "Values to update",
        fields: fields
      });
      cache[updateModelTypeName] = UpdateModelValuesType;

      var UpdateModelWhereType = new GraphQLInputObjectType({
        name: 'Update' + Model.name + 'WhereInput',
        description: "Options to describe the scope of the search.",
        fields: fields
      });

      return {
        values: {
          type: UpdateModelValuesType
        },
        where: {
          type: UpdateModelWhereType
        }
      };
    },
    outputFields: function outputFields() {
      var output = {};
      // New Record
      output[camelcase('new_' + Model.name)] = {
        type: modelType,
        description: 'The new ' + Model.name + ', if successfully created.',
        resolve: function resolve(args, e, context, info) {
          return resolver(Model, {})({}, _defineProperty({}, Model.primaryKeyAttribute, args[Model.primaryKeyAttribute]), context, info);
        }
      };

      // New Edges
      _.each(associationsToModel[Model.name], function (a) {
        var from = a.from;
        var atype = a.type;
        var field = a.key;
        // console.log("Edge To", Model.name, "From", from, field, atype);

        if (atype !== "BelongsTo") {
          (function () {
            // HasMany Association
            var connection = associationsFromModel[from][Model.name + '_' + field].connection;

            var fromType = ModelTypes[from];
            // console.log("Connection", Model.name, field, nodeType, conn, association);
            output[camelcase('new_' + fromType.name + '_' + field + '_Edge')] = {
              type: connection.edgeType,
              resolve: function resolve(payload) {
                return connection.resolveEdge(payload);
              }
            };
          })();
        }
      });
      _.each(associationsFromModel[Model.name], function (a) {
        var to = a.to;
        var atype = a.type;
        var foreignKey = a.foreignKey;
        var field = a.key;
        // console.log("Edge From", Model.name, "To", to, field, as, atype, foreignKey);

        if (atype === "BelongsTo") {
          (function () {
            // BelongsTo association
            var toType = ModelTypes[to];
            output[field] = {
              type: toType,
              resolve: function resolve(args, e, context, info) {
                return resolver(Models[toType.name], {})({}, { id: args[foreignKey] }, context, info);
              }
            };
          })();
        }
      });
      // console.log(`${Model.name} mutation output`, output);
      var updateModelOutputTypeName = 'Update' + Model.name + 'Output';
      var outputType = cache[updateModelOutputTypeName] || new GraphQLObjectType({
        name: updateModelOutputTypeName,
        fields: output
      });
      cache[updateModelOutputTypeName] = outputType;

      return {
        'nodes': {
          type: new GraphQLList(outputType),
          resolve: function resolve(source, args, context, info) {
            // console.log('update', source, args);
            return Model.findAll({
              where: source.where
            });
          }
        },
        'affectedCount': {
          type: GraphQLInt
        }
      };
    },
    mutateAndGetPayload: function mutateAndGetPayload(data) {
      // console.log('mutate', data);
      var values = data.values;
      var where = data.where;

      convertFieldsFromGlobalId(Model, values);
      convertFieldsFromGlobalId(Model, where);
      return Model.update(values, {
        where: where
      }).then(function (result) {
        return {
          where: where,
          affectedCount: result[0]
        };
      });
    }
  });
}

function _updateRecord(_ref5) {
  var mutations = _ref5.mutations;
  var Model = _ref5.Model;
  var modelType = _ref5.modelType;
  var ModelTypes = _ref5.ModelTypes;
  var associationsToModel = _ref5.associationsToModel;
  var associationsFromModel = _ref5.associationsFromModel;
  var cache = _ref5.cache;


  var updateMutationName = mutationName(Model, 'updateOne');
  mutations[updateMutationName] = mutationWithClientMutationId({
    name: updateMutationName,
    description: 'Update a single ' + Model.name + ' record.',
    inputFields: function inputFields() {
      var _ref6;

      var fields = attributeFields(Model, {
        exclude: Model.excludeFields ? Model.excludeFields : [],
        commentToDescription: true,
        allowNull: true,
        cache: cache
      });

      convertFieldsToGlobalId(Model, fields);

      var updateModelInputTypeName = 'Update' + Model.name + 'ValuesInput';
      var UpdateModelValuesType = cache[updateModelInputTypeName] || new GraphQLInputObjectType({
        name: updateModelInputTypeName,
        description: "Values to update",
        fields: fields
      });
      cache[updateModelInputTypeName] = UpdateModelValuesType;

      return _ref6 = {}, _defineProperty(_ref6, Model.primaryKeyAttribute, globalIdField(Model.name)), _defineProperty(_ref6, 'values', {
        type: UpdateModelValuesType
      }), _ref6;
    },
    outputFields: function outputFields() {
      var output = {};
      // New Record
      output[camelcase('new_' + Model.name)] = {
        type: modelType,
        description: 'The new ' + Model.name + ', if successfully created.',
        resolve: function resolve(args, e, context, info) {
          return resolver(Model, {})({}, _defineProperty({}, Model.primaryKeyAttribute, args[Model.primaryKeyAttribute]), context, info);
        }
      };

      // New Edges
      _.each(associationsToModel[Model.name], function (a) {
        var from = a.from;
        var atype = a.type;
        var field = a.key;
        // console.log("Edge To", Model.name, "From", from, field, atype);

        if (atype !== "BelongsTo") {
          (function () {
            // HasMany Association
            var connection = associationsFromModel[from][Model.name + '_' + field].connection;

            var fromType = ModelTypes[from];
            // console.log("Connection", Model.name, field, nodeType, conn, association);
            output[camelcase('new_' + fromType.name + '_' + field + '_Edge')] = {
              type: connection.edgeType,
              resolve: function resolve(payload) {
                return connection.resolveEdge(payload);
              }
            };
          })();
        }
      });
      _.each(associationsFromModel[Model.name], function (a) {
        var to = a.to;
        var atype = a.type;
        var foreignKey = a.foreignKey;
        var field = a.key;
        // console.log("Edge From", Model.name, "To", to, field, as, atype, foreignKey);

        if (atype === "BelongsTo") {
          (function () {
            // BelongsTo association
            var toType = ModelTypes[to];
            output[field] = {
              type: toType,
              resolve: function resolve(args, e, context, info) {
                return resolver(Models[toType.name], {})({}, { id: args[foreignKey] }, context, info);
              }
            };
          })();
        }
      });
      // console.log(`${Model.name} mutation output`, output);

      var updateModelOutputTypeName = 'Update' + Model.name + 'Output';
      var outputType = cache[updateModelOutputTypeName] || new GraphQLObjectType({
        name: updateModelOutputTypeName,
        fields: output
      });
      cache[updateModelOutputTypeName] = outputType;

      return output;
    },
    mutateAndGetPayload: function mutateAndGetPayload(data) {
      // console.log('mutate', data);
      var values = data.values;

      var where = _defineProperty({}, Model.primaryKeyAttribute, data[Model.primaryKeyAttribute]);
      convertFieldsFromGlobalId(Model, values);
      convertFieldsFromGlobalId(Model, where);

      return Model.update(values, {
        where: where
      }).then(function (result) {
        return where;
      });
    }
  });
}

function _deleteRecords(_ref7) {
  var mutations = _ref7.mutations;
  var Model = _ref7.Model;
  var modelType = _ref7.modelType;
  var ModelTypes = _ref7.ModelTypes;
  var associationsToModel = _ref7.associationsToModel;
  var associationsFromModel = _ref7.associationsFromModel;
  var cache = _ref7.cache;


  var deleteMutationName = mutationName(Model, 'delete');
  mutations[deleteMutationName] = mutationWithClientMutationId({
    name: deleteMutationName,
    description: 'Delete ' + Model.name + ' records.',
    inputFields: function inputFields() {
      var fields = attributeFields(Model, {
        exclude: Model.excludeFields ? Model.excludeFields : [],
        commentToDescription: true,
        allowNull: true,
        cache: cache
      });
      convertFieldsToGlobalId(Model, fields);
      var DeleteModelWhereType = new GraphQLInputObjectType({
        name: 'Delete' + Model.name + 'WhereInput',
        description: "Options to describe the scope of the search.",
        fields: fields
      });
      return {
        where: {
          type: DeleteModelWhereType
        }
      };
    },
    outputFields: function outputFields() {
      return {
        'affectedCount': {
          type: GraphQLInt
        }
      };
    },
    mutateAndGetPayload: function mutateAndGetPayload(data) {
      var where = data.where;

      convertFieldsFromGlobalId(Model, where);
      return Model.destroy({
        where: where
      }).then(function (affectedCount) {
        return {
          where: where,
          affectedCount: affectedCount
        };
      });
    }
  });
}

function _deleteRecord(_ref8) {
  var mutations = _ref8.mutations;
  var Model = _ref8.Model;
  var modelType = _ref8.modelType;
  var ModelTypes = _ref8.ModelTypes;
  var associationsToModel = _ref8.associationsToModel;
  var associationsFromModel = _ref8.associationsFromModel;
  var cache = _ref8.cache;


  var deleteMutationName = mutationName(Model, 'deleteOne');
  mutations[deleteMutationName] = mutationWithClientMutationId({
    name: deleteMutationName,
    description: 'Delete single ' + Model.name + ' record.',
    inputFields: function inputFields() {
      return _defineProperty({}, Model.primaryKeyAttribute, globalIdField(Model.name));
    },
    outputFields: function outputFields() {
      var idField = camelcase('deleted_' + Model.name + '_id');
      return _defineProperty({}, idField, {
        type: GraphQLID,
        resolve: function resolve(source) {
          return source[Model.primaryKeyAttribute];
        }
      });
    },
    mutateAndGetPayload: function mutateAndGetPayload(data) {
      var where = _defineProperty({}, Model.primaryKeyAttribute, data[Model.primaryKeyAttribute]);
      convertFieldsFromGlobalId(Model, where);
      return Model.destroy({
        where: where
      }).then(function (affectedCount) {
        return data;
      });
    }
  });
}

function getSchema(sequelize) {
  var _sequelizeNodeInterfa = sequelizeNodeInterface(sequelize);

  var nodeInterface = _sequelizeNodeInterfa.nodeInterface;
  var nodeField = _sequelizeNodeInterfa.nodeField;
  var nodeTypeMapper = _sequelizeNodeInterfa.nodeTypeMapper;


  var Models = sequelize.models;
  var queries = {};
  var mutations = {};
  var associationsToModel = {};
  var associationsFromModel = {};
  var cache = {};

  // Create types map
  var ModelTypes = Object.keys(Models).reduce(function (types, key) {
    var Model = Models[key];
    var modelType = new GraphQLObjectType({
      name: Model.name,
      fields: function fields() {
        // Lazily load fields
        return Object.keys(Model.associations).reduce(function (fields, akey) {
          var association = Model.associations[akey];
          var atype = association.associationType;
          var target = association.target;
          var targetType = ModelTypes[target.name];
          if (atype === "BelongsTo") {
            fields[akey] = {
              type: targetType,
              resolve: resolver(association, {
                separate: true
              })
            };
          } else {
            var connectionName = connectionNameForAssociation(Model, akey);
            var connection = ModelTypes[connectionName];
            fields[akey] = {
              type: connection.connectionType,
              args: connection.connectionArgs,
              resolve: connection.resolve
            };
          }
          return fields;
        },
        // Attribute fields
        attributeFields(Model, {
          exclude: Model.excludeFields ? Model.excludeFields : [],
          globalId: true,
          commentToDescription: true,
          cache: cache
        }));
      },
      interfaces: [nodeInterface]
    });
    types[Model.name] = modelType;
    // === CRUD ====
    // CREATE single
    _createRecord({
      mutations: mutations,
      Model: Model,
      modelType: modelType,
      ModelTypes: types,
      associationsToModel: associationsToModel,
      associationsFromModel: associationsFromModel,
      cache: cache
    });

    // READ single
    _findRecord({
      queries: queries,
      Model: Model,
      modelType: modelType
    });

    // READ all
    _findAll({
      queries: queries,
      Model: Model,
      modelType: modelType
    });

    // UPDATE single
    _updateRecord({
      mutations: mutations,
      Model: Model,
      modelType: modelType,
      ModelTypes: types,
      associationsToModel: associationsToModel,
      associationsFromModel: associationsFromModel,
      cache: cache
    });

    // UPDATE multiple
    _updateRecords({
      mutations: mutations,
      Model: Model,
      modelType: modelType,
      ModelTypes: types,
      associationsToModel: associationsToModel,
      associationsFromModel: associationsFromModel,
      cache: cache
    });

    // DELETE single
    _deleteRecord({
      mutations: mutations,
      Model: Model,
      modelType: modelType,
      ModelTypes: types,
      associationsToModel: associationsToModel,
      associationsFromModel: associationsFromModel,
      cache: cache
    });

    _deleteRecords({
      mutations: mutations,
      Model: Model,
      modelType: modelType,
      ModelTypes: types,
      associationsToModel: associationsToModel,
      associationsFromModel: associationsFromModel,
      cache: cache
    });

    return types;
  }, {});

  // Create Connections
  _.each(Models, function (Model) {
    _.each(Model.associations, function (association, akey) {

      var atype = association.associationType;
      var target = association.target;
      var foreignKey = association.foreignKey;
      var as = association.as;
      var targetType = ModelTypes[target.name];
      var connectionName = connectionNameForAssociation(Model, akey);
      if (atype === "BelongsTo") {
        // BelongsTo
        _.set(associationsToModel, targetType.name + '.' + akey, {
          from: Model.name,
          type: atype,
          key: akey,
          foreignKey: foreignKey,
          as: as
        });
        _.set(associationsFromModel, Model.name + '.' + akey, {
          to: targetType.name,
          type: atype,
          key: akey,
          foreignKey: foreignKey,
          as: as
        });
      } else {
        // HasMany
        var edgeFields = {};
        if (atype === "BelongsToMany") {
          (function () {
            var aModel = association.through.model;
            // console.log('BelongsToMany model', aModel);
            edgeFields = attributeFields(aModel, {
              exclude: aModel.excludeFields ? aModel.excludeFields : [],
              globalId: true,
              commentToDescription: true,
              cache: cache
            });
            // Pass Through model to resolve function
            _.each(edgeFields, function (edgeField, field) {
              var oldResolve = edgeField.resolve;
              // console.log(field, edgeField, Object.keys(edgeField));
              if (typeof oldResolve !== 'function') {
                // console.log(oldResolve);
                var resolve = function resolve(source, args, context, info) {
                  var e = source.node[aModel.name];
                  return e[field];
                };
                edgeField.resolve = resolve.bind(edgeField);
              } else {
                var _resolve = function _resolve(source, args, context, info) {
                  var e = source.node[aModel.name];
                  return oldResolve(e, args, context, info);
                };
                edgeField.resolve = _resolve.bind(edgeField);
              }
            });
          })();
        }

        var connection = sequelizeConnection({
          name: connectionName,
          nodeType: targetType,
          target: association,
          connectionFields: {
            total: {
              type: new GraphQLNonNull(GraphQLInt),
              description: 'Total count of ' + targetType.name + ' results associated with ' + Model.name + '.',
              resolve: function resolve(_ref11) {
                var source = _ref11.source;
                var accessors = association.accessors;

                return source[accessors.count]();
              }
            }
          },
          edgeFields: edgeFields
        });
        ModelTypes[connectionName] = connection;
        _.set(associationsToModel, targetType.name + '.' + Model.name + '_' + akey, {
          from: Model.name,
          type: atype,
          key: akey,
          connection: connection,
          as: as
        });
        _.set(associationsFromModel, Model.name + '.' + targetType.name + '_' + akey, {
          to: targetType.name,
          type: atype,
          key: akey,
          connection: connection,
          as: as
        });
      }
    });
  });
  // console.log("associationsToModel", associationsToModel);
  // console.log("associationsFromModel", associationsFromModel);

  // Custom Queries and Mutations
  _.each(Object.keys(Models), function (key) {
    var Model = Models[key];

    // Custom Queries
    if (Model.queries) {
      _.assign(queries, Model.queries(Models, ModelTypes, resolver));
    }
    // Custom Mutations
    if (Model.mutations) {
      _.assign(mutations, Model.mutations(Models, ModelTypes, resolver));
    }
  });

  // Configure NodeTypeMapper
  nodeTypeMapper.mapTypes(_extends({}, ModelTypes));

  var Queries = new GraphQLObjectType({
    name: "Root",
    description: "Root of the Schema",
    fields: function fields() {
      return _extends({
        root: {
          // Cite: https://github.com/facebook/relay/issues/112#issuecomment-170648934
          type: new GraphQLNonNull(Queries),
          description: "Self-Pointer from Root to Root",
          resolve: function resolve() {
            return {};
          }
        }
      }, queries, {
        node: nodeField
      });
    }
  });

  var Mutations = new GraphQLObjectType({
    name: "Mutations",
    fields: _extends({}, mutations)
  });

  return new GraphQLSchema({
    query: Queries,
    mutation: Mutations
  });
};

module.exports = {
  getSchema: getSchema
};